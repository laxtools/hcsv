# hcsv json 

스키마를 json으로 정의한다. 일반적이며 C++ / C#에서 별도의 컴파일러 도구 없이 구현 가능하다. 이 쪽 방향으로 진행한다. 



# 데이터 만들기 

데이터를 기반으로 진행한다.  게임에서 필요한 데이터는 테이블로 정의할 수 있다. 관계형 데이터로만 표현하면 외부 참조가 너무 많아져 불편해진다. 이런 문제를 게임 개발에서는 필드 내 행 데이터를 추가하여 해결한다. 

이외에 트리 형태로 속성 창에서 볼 수 있는 형태의 값 편집이 있다. 행으로 만들고 행의 필드가 다른 구조의 행을 포함할 수 있게 하면 동일한 구조다. 

```json
{
    "type" : "row", 
    "fields" : {
        "name" : {
            "type" : "number",        	 
            "contraint" : {
                "primary key"
                "length" : "~20"
            }
        }, 
        "reward" : {
            "type" : "array", 
            "value" : "number"
        }
    }
}
```

무한으로 포함 가능하면 편집이 어렵다. 따라서, 레벨 제한이 필요하다. 보통은 한 단계 정도면 충분할 것이다.  

```
kdpark, [1357, 1234, 313], { ac, 9.7, 10 }, 111, 123, 0, false 
```

[]는 배열이고 {}는 구조체이다. 이를 통해 csv가 확장된다. json과 동치이며 스키마 분리를 통해 타잎 지정을 매번 해야 하는 구조에서 벗어난다. 행 자체는 타잎화 되지만 타잎 지정은 매우 자유롭다. 

이제 이런 것이 가능하다. 

```
{
    [1, 2, 3], 
    {npc 1, 103915}, 
    97
}
```

위는 다음과 같은 스키마에서 만들어진다. 

```
{ array : number, struct : [ string, number, number ] }
```

구조체 배열을 쉽게 지정하면 좋다. 어떤 방법이 있을까? 

```
{ array : [ string, number, number ] }
```

정확한 json으로 하면 다음과 같다. 

```json
{
    "array" : [ "string", "number", "number" ], 
    "struct" : [ "strng", "number", "date" ]
}
```

위와 같이 하면 데이터는 다음과 같다. 

```
[ {"a", 1, 2 }, {"b", 2, 4} ]
```

배열의 개수는 제한될 수 있다. 완전한 스키마 구조는 더 길어질 수 밖에 없다.  HCSV를 데이터 중심으로 정의하고 C#, C++ 관리 코드 생성을 먼저 진행한다. 이후 편집기를 만든다. 둘은 병행해도 되는 작업이다. 어떻게 할까? 









